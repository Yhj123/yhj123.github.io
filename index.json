[{"categories":["嵌入式"],"content":"文件结构 ","date":"2023-12-04","objectID":"/posts/%E5%B5%8C%E5%85%A5%E5%BC%8F/stm32/stm32%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/:1:0","tags":["STM32"],"title":"STM32工程结构以及开发流程","uri":"/posts/%E5%B5%8C%E5%85%A5%E5%BC%8F/stm32/stm32%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"},{"categories":["嵌入式"],"content":"STM32F10x_StdPeriph_Lib_V3.6.0 文件树 STM32F10x_StdPeriph_Lib_V3.6 ├── Libraries // 驱动库的源代码与启动文件 ├── Project // 驱动库写的例子和一个工程模版 ├── stm32f10x_stdperiph_lib_um.chm // 固件库使用手册和应用举例 └── Utilities // ST 公司评估板的相关例程代码 Libraries 文件夹 Libraries ├── CMSIS // Cortex-M3 内核自带的外设驱动代码和启动代码 │ ├── CM3 │ │ ├── CoreSupport // Cortex-M3 内核自带的外设驱动代码 │ │ │ ├── core_cm3.c │ │ │ └── core_cm3.h │ │ └── DeviceSupport │ │ └── ST │ │ └── STM32F10x │ │ ├── LICENSE.txt │ │ ├── Release_Notes.html │ │ ├── startup // 包含 arm 等四个对应不同开发环境的启动代码文件夹 │ │ │ ├── arm // 对应 Keil 开发环境下不同容量(小(LD),中(MD),大(HD)容量Flash)芯片的启动代码. │ │ │ │ ├── startup_stm32f10x_cl.s │ │ │ │ ├── startup_stm32f10x_hd.s │ │ │ │ ├── startup_stm32f10x_hd_vl.s │ │ │ │ ├── startup_stm32f10x_ld.s │ │ │ │ ├── startup_stm32f10x_ld_vl.s │ │ │ │ ├── startup_stm32f10x_md.s │ │ │ │ ├── startup_stm32f10x_md_vl.s │ │ │ │ └── startup_stm32f10x_xl.s │ │ │ ├── gcc_ride7 │ │ │ │ ├── startup_stm32f10x_cl.s │ │ │ │ ├── startup_stm32f10x_hd.s │ │ │ │ ├── startup_stm32f10x_hd_vl.s │ │ │ │ ├── startup_stm32f10x_ld.s │ │ │ │ ├── startup_stm32f10x_ld_vl.s │ │ │ │ ├── startup_stm32f10x_md.s │ │ │ │ ├── startup_stm32f10x_md_vl.s │ │ │ │ └── startup_stm32f10x_xl.s │ │ │ ├── iar │ │ │ │ ├── startup_stm32f10x_cl.s │ │ │ │ ├── startup_stm32f10x_hd.s │ │ │ │ ├── startup_stm32f10x_hd_vl.s │ │ │ │ ├── startup_stm32f10x_ld.s │ │ │ │ ├── startup_stm32f10x_ld_vl.s │ │ │ │ ├── startup_stm32f10x_md.s │ │ │ │ ├── startup_stm32f10x_md_vl.s │ │ │ │ └── startup_stm32f10x_xl.s │ │ │ └── TrueSTUDIO │ │ │ ├── startup_stm32f10x_cl.s │ │ │ ├── startup_stm32f10x_hd.s │ │ │ ├── startup_stm32f10x_hd_vl.s │ │ │ ├── startup_stm32f10x_ld.s │ │ │ ├── startup_stm32f10x_ld_vl.s │ │ │ ├── startup_stm32f10x_md.s │ │ │ ├── startup_stm32f10x_md_vl.s │ │ │ └── startup_stm32f10x_xl.s │ │ ├── stm32f10x.h │ │ ├── system_stm32f10x.c │ │ └── system_stm32f10x.h │ ├── CMSIS changes.htm │ ├── CMSIS debug support.htm │ ├── Documentation │ │ └── CMSIS_Core.htm │ └── License.doc └── STM32F10x_StdPeriph_Driver // Cortex-M3 内核上外加的外设驱动代码 ├── inc // include缩写 │ ├── misc.h │ ├── stm32f10x_adc.h │ ├── stm32f10x_bkp.h │ ├── stm32f10x_can.h │ ├── stm32f10x_cec.h │ ├── stm32f10x_crc.h │ ├── stm32f10x_dac.h │ ├── stm32f10x_dbgmcu.h │ ├── stm32f10x_dma.h │ ├── stm32f10x_exti.h │ ├── stm32f10x_flash.h │ ├── stm32f10x_fsmc.h │ ├── stm32f10x_gpio.h │ ├── stm32f10x_i2c.h │ ├── stm32f10x_iwdg.h │ ├── stm32f10x_pwr.h │ ├── stm32f10x_rcc.h │ ├── stm32f10x_rtc.h │ ├── stm32f10x_sdio.h │ ├── stm32f10x_spi.h │ ├── stm32f10x_tim.h │ ├── stm32f10x_usart.h │ └── stm32f10x_wwdg.h ├── LICENSE.txt ├── Release_Notes.html └── src // source 缩写 ├── misc.c ├── stm32f10x_adc.c ├── stm32f10x_bkp.c ├── stm32f10x_can.c ├── stm32f10x_cec.c ├── stm32f10x_crc.c ├── stm32f10x_dac.c ├── stm32f10x_dbgmcu.c ├── stm32f10x_dma.c ├── stm32f10x_exti.c ├── stm32f10x_flash.c ├── stm32f10x_fsmc.c ├── stm32f10x_gpio.c ├── stm32f10x_i2c.c ├── stm32f10x_iwdg.c ├── stm32f10x_pwr.c ├── stm32f10x_rcc.c ├── stm32f10x_rtc.c ├── stm32f10x_sdio.c ├── stm32f10x_spi.c ├── stm32f10x_tim.c ├── stm32f10x_usart.c └── stm32f10x_wwdg.c Project文件夹 Project ├── STM32F10x_StdPeriph_Examples └── STM32F10x_StdPeriph_Template STM32F10x_StdPeriph_Template 文件夹 STM32F10x_StdPeriph_Template ├── EWARM ├── HiTOP ├── LICENSE.txt ├── main.c ├── MDK-ARM ├── Release_Notes.html ├── RIDE ├── stm32f10x_conf.h // 外设头文件配置文件 ├── stm32f10x_it.c // 中断函数文件 ├── stm32f10x_it.h ├── system_stm32f10x.c // 更改程序的时钟配置,根据 HSE 或者 HSI 设置系统时钟和总线时钟(AHB, APBI, APB2总线). └── TrueSTUDIO ","date":"2023-12-04","objectID":"/posts/%E5%B5%8C%E5%85%A5%E5%BC%8F/stm32/stm32%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/:1:1","tags":["STM32"],"title":"STM32工程结构以及开发流程","uri":"/posts/%E5%B5%8C%E5%85%A5%E5%BC%8F/stm32/stm32%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"},{"categories":["嵌入式"],"content":"startup_stm32xxxxx.s 文件 startup_stm32xxxxx.s的文件中使用汇编语言写好了基本程序，当STM32芯片上电启动的时候，首先会执行这里的汇编程序，从而建立C语言的运行环境，所以这个文件称为启动文件. startup_stm32xxxxx.s 文件功能: 初始化堆栈指针SP. 初始化程序计数器指针PC. 设置堆和栈的大小. 设置中断向量表的入口地址. 配置外部SRAM作为数据存储器(由用户配置, 一般的开发板没有外部SRAM). 调用SystemInit()函数配置 STM32 的系统时钟. 设置C库的分支入口“__main”(最终用来调用main函数). ","date":"2023-12-04","objectID":"/posts/%E5%B5%8C%E5%85%A5%E5%BC%8F/stm32/stm32%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/:1:2","tags":["STM32"],"title":"STM32工程结构以及开发流程","uri":"/posts/%E5%B5%8C%E5%85%A5%E5%BC%8F/stm32/stm32%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"},{"categories":["嵌入式"],"content":"stm32f4xx.h 文件 根据 STM32 的存储分配先定义好各个寄存器的地址,把这些地址定义都统一写在 stm32f4xx.h 文件中. ","date":"2023-12-04","objectID":"/posts/%E5%B5%8C%E5%85%A5%E5%BC%8F/stm32/stm32%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/:1:3","tags":["STM32"],"title":"STM32工程结构以及开发流程","uri":"/posts/%E5%B5%8C%E5%85%A5%E5%BC%8F/stm32/stm32%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"},{"categories":["嵌入式"],"content":"main.c 文件","date":"2023-12-04","objectID":"/posts/%E5%B5%8C%E5%85%A5%E5%BC%8F/stm32/stm32%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/:1:4","tags":["STM32"],"title":"STM32工程结构以及开发流程","uri":"/posts/%E5%B5%8C%E5%85%A5%E5%BC%8F/stm32/stm32%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"},{"categories":["linux命令"],"content":"概述 nohup 全称 no hang up(不挂起),nohup 命令可以让你在退出终端或关闭SSH连接后继续运行命令. ","date":"2023-11-24","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/linux%E5%91%BD%E4%BB%A4/nohup%E5%91%BD%E4%BB%A4/:1:0","tags":["操作系统"],"title":"Nohup命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/linux%E5%91%BD%E4%BB%A4/nohup%E5%91%BD%E4%BB%A4/"},{"categories":["linux命令"],"content":"链接 深入解析Linux的nohup命令 ","date":"2023-11-24","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/linux%E5%91%BD%E4%BB%A4/nohup%E5%91%BD%E4%BB%A4/:2:0","tags":["操作系统"],"title":"Nohup命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/linux%E5%91%BD%E4%BB%A4/nohup%E5%91%BD%E4%BB%A4/"},{"categories":["linux命令"],"content":"CP 命令 语法 语法 cp(选项)(参数) 语法 cp(选项)(参数) ","date":"2023-11-22","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/linux%E5%91%BD%E4%BB%A4/cp%E5%91%BD%E4%BB%A4%E4%B8%8Escp%E5%91%BD%E4%BB%A4/:1:0","tags":["操作系统"],"title":"CP命令与SCP命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/linux%E5%91%BD%E4%BB%A4/cp%E5%91%BD%E4%BB%A4%E4%B8%8Escp%E5%91%BD%E4%BB%A4/"},{"categories":["linux源码学习"],"content":"第一行代码: 加载启动区 操作系统的开发人员,会把操作系统最开始的那段代码1，编译并存储在硬盘的 0 盘 0 道 1 扇区.按下开机键的那一刻，CPU会自动把代码段寄存器 CS 设置为 0xF000, 其段基地址则被设置为 0xFFFF0000, 段长度设置为 64KB。而 IP 被设置为0xFFF0,因此此时CPU代码指针指向 0xFFFFFFF0 处,即4G空间最后一个64K的最后16字节处,即系统 ROM BIOS 存放的位置.在主板上提前写死的固件程序 BIOS 会将硬盘中启动区2的 512 字节的数据，原封不动复制到内存中的 0x7c00 这个位置，并跳转到那个位置进行执行. mov ax,0x07c0 !将值 0x07c0 复制到 ax 寄存器里 mov ds,ax !将 ax 寄存器里的值复制到 ds 寄存器 mov ax,0x9000 mov es,ax mov cx,#256 ！计数器，提供需要复制的字的数量 256字=512字节 sub si,si !sub指令作用：减法操作,即 si 寄存器清零. sub di,di rep !rep指令作用：重复执行后面一句操作，并递减cx的值，直到cx=0停止. movw !movw指令作用：这里从内存 [si] 处移动 cx 个字到 [di]；注意一次的移动单位是“字”，mov指令+w（word）是一次移动一个字. jmpi go,INITSEG !将BIOS移动到0x9000后，跳转（go）到INITSEG（0x9000），CS=0x90000 go: mov ax,cs mov ds,ax mov es,ax 解释 一段 512 字节的代码和数据，从硬盘的启动区先是被移动到了内存 0x7c00 处，然后又立刻被移动到 0x90000 处，并且跳转到此处往后再稍稍偏移 go 这个标签所代表的偏移地址处，即 mov ax,cs 这行指令的位置. ","date":"2023-11-21","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/linux%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/:1:0","tags":["操作系统"],"title":"Linux系统启动","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/linux%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/"},{"categories":["linux源码学习"],"content":"参考链接 Linux内核源码学习——bootsect.s Linux 源码趣读 linux在线源码 开始的代码是用汇编语言写的 bootsect.s(位于boot 文件夹下). ↩︎ 启动区: 硬盘中的 0 盘 0 道 1 扇区的 512 个字节的最后两个字节(0x55 和 0xaa). ↩︎ ","date":"2023-11-21","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/linux%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/:2:0","tags":["操作系统"],"title":"Linux系统启动","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/linux%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/"},{"categories":["cplusplus"],"content":"元编程 元（meta）无论在中文还是英文里，都是个很“抽象（abstract）”的词。因为它的本意就是“抽象”。元编程，也可以说就是“编程的抽象”。用更好理解的说法，元编程意味着你撰写一段程序A，程序A会运行后生成另外一个程序B，程序B才是真正实现功能的程序。那么这个时候程序A可以称作程序B的元程序，撰写程序A的过程，就称之为“元编程” . 模板能做的事情都是编译期完成的。编译期完成的意思就是,当你编译一个程序的时候,所有的量就都已经确定了. 特化(specialization): 根据一个或多个特殊的整数或类型,给出模板实例化时的一个指定内容. ","date":"2023-11-20","objectID":"/posts/%E5%90%8E%E7%AB%AF/cplusplus/%E6%A8%A1%E7%89%88cplusplus/%E6%A8%A1%E7%89%88/:0:0","tags":["后端"],"title":"模版","uri":"/posts/%E5%90%8E%E7%AB%AF/cplusplus/%E6%A8%A1%E7%89%88cplusplus/%E6%A8%A1%E7%89%88/"},{"categories":["draft"],"content":"链接设计模式 链接设计模式 ","date":"2023-11-18","objectID":"/posts/%E5%90%8E%E7%AB%AF/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/test/:0:0","tags":["draft"],"title":"Test","uri":"/posts/%E5%90%8E%E7%AB%AF/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/test/"},{"categories":["CSharp"],"content":"链接 #include \u003cstdio.h\u003e #include \u003cwinsock2.h\u003e #pragma comment(lib, \"ws2_32\") void bigOrSmall() { int byte = 0x12345678; byte = htonl(byte); /* 1位十六进制数可以用4位二进制数来表示 16进制1位 = 2进制4位 */ char * ptr = (char *)\u0026byte; printf(\"ptr :%lu, byte :%x \\n\",ptr,*ptr); printf(\"ptr+1:%lu, byte+1:%x, \\n\",(ptr+1),*(ptr+1)); } int main() { bigOrSmall(); } ref 与 out 区别 ref 与 out 区别 ","date":"2023-11-18","objectID":"/posts/%E5%90%8E%E7%AB%AF/csharp/ref%E5%85%B3%E9%94%AE%E5%AD%97/:0:0","tags":["后端"],"title":"ref关键字","uri":"/posts/%E5%90%8E%E7%AB%AF/csharp/ref%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["电子电路"],"content":"滤波电路 ","date":"2023-11-18","objectID":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E6%BB%A4%E6%B3%A2%E7%94%B5%E8%B7%AF/:0:0","tags":["模拟电路"],"title":"滤波电路","uri":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E6%BB%A4%E6%B3%A2%E7%94%B5%E8%B7%AF/"},{"categories":["电子电路"],"content":"概述 滤波电路的功能是从众多的信号中选出需要的信号或滤除不需要的信号. 根据电路工作时是否需要电源，滤波电路分为\r无源滤波器和有源滤波器\r；根据电路选取信号的特点，滤波器可分为四种：\r低通滤波器、高通滤波器、带通滤波器和带阻滤波器\r。 ","date":"2023-11-18","objectID":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E6%BB%A4%E6%B3%A2%E7%94%B5%E8%B7%AF/:1:0","tags":["模拟电路"],"title":"滤波电路","uri":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E6%BB%A4%E6%B3%A2%E7%94%B5%E8%B7%AF/"},{"categories":["电子电路"],"content":"无源滤波器 无源滤波器主要由电感、电容和电阻构成，所以又称为 RLC滤波电路.RLC滤波电路可分为低通滤波器、高通滤波器、带通滤波器和带阻滤波器 ","date":"2023-11-18","objectID":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E6%BB%A4%E6%B3%A2%E7%94%B5%E8%B7%AF/:2:0","tags":["模拟电路"],"title":"滤波电路","uri":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E6%BB%A4%E6%B3%A2%E7%94%B5%E8%B7%AF/"},{"categories":["电子电路"],"content":"低通滤波器（LPF） 概述 低通滤波器的功能是选取低频信号，低通滤波器意为\"低频信号可以通过的电路\". 低通滤波电路图例 图(a)所示为 单级RC低通滤波器.当电路输入各种频率的信号时，因为电容C对高频信号阻碍小(根据 \\(\rX_c = \\frac{1}{2πfC}\r\\)\r), 高频信号经电容 C 旁路到地.电容 C 对低频信号阻碍大，低频信号不会旁路，而是输出去后级电路. 图(b)所示为 多级RC低通滤波器.针对单级 RC 低通滤波器滤波效果达不到要求.这种滤波器能更彻底地滤掉高频信号. 图(c)所示为 RL低通滤波器.当电路输入各种频率的信号时，因为电感对高频信号阻碍大(根据 \\(\rX_L = 2πfL\r\\)\r)，高频信号很难通过电感 L,而电感对低频信号阻碍小, 低频信号很容易通过电感去后级电路. ","date":"2023-11-18","objectID":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E6%BB%A4%E6%B3%A2%E7%94%B5%E8%B7%AF/:2:1","tags":["模拟电路"],"title":"滤波电路","uri":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E6%BB%A4%E6%B3%A2%E7%94%B5%E8%B7%AF/"},{"categories":["电子电路"],"content":"高通滤波器（HPF） 概述 高通滤波器的功能是选取高频信号，高通滤波器意为\"高频信号可以通过的电路\". 高通滤波电路图例 图(a)所示为 RC高通滤波器.当电路输入各种频率的信号时，因为电容 C 对高频信号阻碍小, 对低频信号阻碍大, 故低频信号难于通过电容 C，高频信号很容易通过电容去后级电路. 图(b)所示为 RL高通滤波器.当电路输入各种频率的信号时, 因为电感 L 对高频信号阻碍大, 对低频信号阻碍小, 故低频信号很容易通过电感 L 旁路到地, 高频信号不容易被电感旁路而只能去后级电路. 图(c)所示为 滤波效果更好的高通滤波器.电容C1、C2 对高频信号阻碍小、对低频信号阻碍大，低频信号难于通过，高频信号很容易通过；另外, 电感 L 对高频信号阻碍大, 对低频信号阻碍小，低频信号很容易被旁路掉，高频信号则不容易被旁路掉. ","date":"2023-11-18","objectID":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E6%BB%A4%E6%B3%A2%E7%94%B5%E8%B7%AF/:2:2","tags":["模拟电路"],"title":"滤波电路","uri":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E6%BB%A4%E6%B3%A2%E7%94%B5%E8%B7%AF/"},{"categories":["电子电路"],"content":"带通滤波器（BPF） 概述 带通滤波器的功能是选取某一段频率范围内的信号. 带通滤波器电路图例 图(a) 所示为 RC 元件构成的带通滤波器. 其中 R1, C1 构成低通滤波器，它的截止频率1为 fH，可以通过 fH 频率以下的信号. C2, R2 构成高通滤波器，它的截止频率为 fL，可以通过 fL 频率以上的信号.结果只有 fL～fH 频率范围的信号通过整个滤波器. 图(b) 所示为 LC 串联谐振电路2构成的带通滤波器. L1, C1 谐振频率为 f0，它对频率为 f0 的信号阻碍小, 对其他频率的信号阻碍很大, 故只有频率为 f0 的信号可以通过. 该电路可以选取单一频率的信号, 如果想让 f0 附近频率的信号也能通过，就要降低谐振电路的 Q 值，Q 值越低，LC 电路的通频带越宽，能通过 f0 附近更多频率的信号. 图(c) 所示为 LC并联谐振电路2构成的带通滤波器, L1, C1谐振频率为 f0，它对频率为 f0 的信号阻碍很大，对其他频率的信号阻碍小，故其他频率的信号被旁路，只有频率为 f0 的信号不会被旁路，而去后级电路. ","date":"2023-11-18","objectID":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E6%BB%A4%E6%B3%A2%E7%94%B5%E8%B7%AF/:2:3","tags":["模拟电路"],"title":"滤波电路","uri":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E6%BB%A4%E6%B3%A2%E7%94%B5%E8%B7%AF/"},{"categories":["电子电路"],"content":"带阻滤波器（BEF） 概述 带阻滤波器的功能是选取某一段频率范围以外的信号. 带阻滤波器又称陷波器. ","date":"2023-11-18","objectID":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E6%BB%A4%E6%B3%A2%E7%94%B5%E8%B7%AF/:2:4","tags":["模拟电路"],"title":"滤波电路","uri":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E6%BB%A4%E6%B3%A2%E7%94%B5%E8%B7%AF/"},{"categories":["电子电路"],"content":"有源滤波器 有源滤波器一般由有源器件（运算放大器）和RC元件构成 ","date":"2023-11-18","objectID":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E6%BB%A4%E6%B3%A2%E7%94%B5%E8%B7%AF/:3:0","tags":["模拟电路"],"title":"滤波电路","uri":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E6%BB%A4%E6%B3%A2%E7%94%B5%E8%B7%AF/"},{"categories":["电子电路"],"content":"引用参考 当带通滤波器输入0～f1频率范围的信号时，经滤波器后输出 fL～fH 频率范围的信号，这里的 fL 称为下限截止频率，fH 称为上限截止频率. ↩︎ 谐振电路\r ↩︎ ↩︎ ","date":"2023-11-18","objectID":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E6%BB%A4%E6%B3%A2%E7%94%B5%E8%B7%AF/:4:0","tags":["模拟电路"],"title":"滤波电路","uri":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E6%BB%A4%E6%B3%A2%E7%94%B5%E8%B7%AF/"},{"categories":["draft"],"content":"太空气候建模 链接 科学60s ","date":"2023-11-18","objectID":"/posts/%E8%8B%B1%E6%96%87/scientificamerican/%E5%A4%AA%E7%A9%BA%E6%B0%94%E5%80%99%E5%BB%BA%E6%A8%A1/:0:0","tags":["draft"],"title":"太空气候建模","uri":"/posts/%E8%8B%B1%E6%96%87/scientificamerican/%E5%A4%AA%E7%A9%BA%E6%B0%94%E5%80%99%E5%BB%BA%E6%A8%A1/"},{"categories":["电子电路"],"content":"谐振电路 ","date":"2023-11-18","objectID":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E8%B0%90%E6%8C%AF%E7%94%B5%E8%B7%AF/:0:0","tags":["模拟电路"],"title":"谐振电路","uri":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E8%B0%90%E6%8C%AF%E7%94%B5%E8%B7%AF/"},{"categories":["电子电路"],"content":"概述 谐振电路是一种由电感和电容构成的电路，故又称为LC谐振电路.谐振电路分为 串联谐振电路 和 并联谐振电路. ","date":"2023-11-18","objectID":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E8%B0%90%E6%8C%AF%E7%94%B5%E8%B7%AF/:1:0","tags":["模拟电路"],"title":"谐振电路","uri":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E8%B0%90%E6%8C%AF%E7%94%B5%E8%B7%AF/"},{"categories":["电子电路"],"content":"串联谐振电路 ","date":"2023-11-18","objectID":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E8%B0%90%E6%8C%AF%E7%94%B5%E8%B7%AF/:2:0","tags":["模拟电路"],"title":"谐振电路","uri":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E8%B0%90%E6%8C%AF%E7%94%B5%E8%B7%AF/"},{"categories":["电子电路"],"content":"概述 电容和电感头尾相连，并与交流信号连接在一起就构成了串联谐振电路. ","date":"2023-11-18","objectID":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E8%B0%90%E6%8C%AF%E7%94%B5%E8%B7%AF/:2:1","tags":["模拟电路"],"title":"谐振电路","uri":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E8%B0%90%E6%8C%AF%E7%94%B5%E8%B7%AF/"},{"categories":["电子电路"],"content":"串联谐振电路谐振时的特点 在串联谐振电路中，当交流信号频率为某一值（f0）时，电路出现最大电流的现象称为串联谐振现象，简称串联谐振，这个频率称为谐振频率，用 f0 表示. \\[\rf_0 = \\frac{1}{2π\\sqrt{LC}}\r\\]\r谐振时，电路中的电流最大，此时 LC 元件串在一起就像一只阻值很小的电阻，即串联谐振电路谐振时总阻抗最小（电阻、容抗和感抗统称为 阻抗，用Z表示，阻抗单位为Ω）. 谐振时，电路中电感上的电压 UL 和电容上的电压 UC 都很高，往往比交流信号电压 U 大 Q 倍( UL = UC = Q × U，Q为品质因数, \\(\rQ = \\frac{2πfL}{R}\r\\)\r), 因此串联谐振又称为 电压谐振\r。在谐振时，UL 与 UC 电压在数值上相等，但两者极性相反，故两电压之和（UL + UC）近似为零. ","date":"2023-11-18","objectID":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E8%B0%90%E6%8C%AF%E7%94%B5%E8%B7%AF/:2:2","tags":["模拟电路"],"title":"谐振电路","uri":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E8%B0%90%E6%8C%AF%E7%94%B5%E8%B7%AF/"},{"categories":["电子电路"],"content":"并联谐振电路 ","date":"2023-11-18","objectID":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E8%B0%90%E6%8C%AF%E7%94%B5%E8%B7%AF/:3:0","tags":["模拟电路"],"title":"谐振电路","uri":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E8%B0%90%E6%8C%AF%E7%94%B5%E8%B7%AF/"},{"categories":["电子电路"],"content":"概述 电容和电感头头相连、尾尾相接与交流信号连接起来就构成了并联谐振电路。 ","date":"2023-11-18","objectID":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E8%B0%90%E6%8C%AF%E7%94%B5%E8%B7%AF/:3:1","tags":["模拟电路"],"title":"谐振电路","uri":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E8%B0%90%E6%8C%AF%E7%94%B5%E8%B7%AF/"},{"categories":["电子电路"],"content":"并联谐振电路谐振时的特点 在并联谐振电路中，当交流信号频率为某一值（f0）时，电路出现最小电流的现象称为并联谐振现象，简称并联谐振，这个频率称为谐振频率，用 f0 表示. \\[\rf_0 = \\frac{1}{2π\\sqrt{LC}}\r\\]\r谐振时，电路中的电流I最小，此时 LC 元件并在一起就像一只阻值很大的电阻，即并联谐振电路谐振时总阻抗最大。 谐振时，流过电容支路的电流 IC 和流过电感支路的电流 IL 比总电流 I 大很多倍，故并联谐振又称为 电流谐振\r。其中 IC 与 IL 数值相等，但方向相反，IC 与 IL 在 LC 支路构成的回路中流动，不会流过主干路. ","date":"2023-11-18","objectID":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E8%B0%90%E6%8C%AF%E7%94%B5%E8%B7%AF/:3:2","tags":["模拟电路"],"title":"谐振电路","uri":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E8%B0%90%E6%8C%AF%E7%94%B5%E8%B7%AF/"},{"categories":["电子电路"],"content":"整流电路 ","date":"2023-11-18","objectID":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E6%95%B4%E6%B5%81%E7%94%B5%E8%B7%AF/:0:0","tags":["模拟电路"],"title":"整流电路","uri":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E6%95%B4%E6%B5%81%E7%94%B5%E8%B7%AF/"},{"categories":["电子电路"],"content":"概述 整流电路的功能是将交流电转换成直流电.整流电路主要有\r半波整流电路、全波整流电路、桥式整流电路和倍压整流电路\r等 ","date":"2023-11-18","objectID":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E6%95%B4%E6%B5%81%E7%94%B5%E8%B7%AF/:1:0","tags":["模拟电路"],"title":"整流电路","uri":"/posts/%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/%E6%95%B4%E6%B5%81%E7%94%B5%E8%B7%AF/"}]